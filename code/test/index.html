<!DOCTYPE html>
<html>
<head>
<link href="http://fonts.googleapis.com/css?family=Roboto+Slab:700|Open+Sans:300italic,400,300,600,600italic" rel="stylesheet" type="text/css">
</head>
<body style="background-color:rgb(249,249,249);">

<p style="font-size:16px;font-family: 'open sans',Helvetica,'sans serif'">Dear Clinton,</p>

<p style="font-size:16px;font-family: 'open sans',Helvetica,'sans serif'">Thank you for the lovely post.  Here is a copy of the neistat brothers HBO show on DVD.  It originally aired in the summer of 2010.</p>

<p style="font-size:16px;font-family: 'open sans',Helvetica,'sans serif'">Servidor de usted,</p>

<h2>--van</h2>

<p>some dummy untyped content -- style="background-color:rgb(0,0,0);color:rgb(255,255,255);"</p>

<hr>

<p class="analogue">Dear Clinton,</p>

<p class="analogue" style="font-size:16px;font-family: 'open sans',Helvetica,'sans serif'">Thank you for the lovely post.  Here is a copy of the neistat brothers HBO show on DVD.  It originally aired in the summer of 2010.</p>

<p class="analogue">Servidor de usted,</p>

<h2 class="analogue">--van</h2>

<script>
"use strict"

/**
 * Copyright (c) Clinton Freeman 2015
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
 * associated documentation files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge, publish, distribute,
 * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or
 * substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
 * NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// TODO: multi-line paragraphs.
// TODO: Render random correction tape behind some sections of the text.
// TODO: Margins are not being copied correctly in firefox developer edition. 
// TODO: Estimate # lines by using total rendered character length.

/**
 Work out line: measure text size of string indexed at known width of canvas.
 If string indexed lands on non white space, rfind white space. That is the line of type. If the line lands on white space, move forward till we find non-white space. That will be the start of the next line. Repeat. Building lines till we are out of input text.

 Use total number of lines and line height to work out total vertical space required.
 */

var smudge = ["q", "r", "o", "p", "a", "d", "b", "4", "6", "8", "9", "0", "@", "%", "&"];

function rand(iStart, iEnd) {
  return Math.floor((Math.random() * iEnd) + iStart) | 0;
}

function randF(fStart, fEnd) {
  return (Math.random() * fEnd) + fStart;
}

function parseColor(sColor) {
  var result = sColor.match(/\d+/g).map(function(sValue) {
    return parseInt(sValue);
  });

  // Make sure the color is rgba.
  if (result.length < 4) {
    var iSize = 4 - result.length;
    while(iSize--) {result.push(1)}
  }

  return result;
}

function randAlphaC(cColor, fStart, fEnd) {
  var result = cColor.slice();
  result[3] = randF(fStart, fEnd);

  return result;
}

function colorToS(cColor) {
  return "rgba("+cColor[0]+","+cColor[1]+","+cColor[2]+","+cColor[3]+")";
}

function chance(iProbability) {
  if (rand(0, 100) >= (100 - iProbability)) {
    return true;
  }

  return false;
}

function generateInkStrike(ctx, iHOffset, iWidth,
                           iHeight, cForeground, cBackground) {
  var hLower = (iHeight * 0.7) | 0;
  var hUpper = iHeight;

  var wLower = iHOffset;
  var wUpper = iWidth;

  var hGradient = rand(hLower, hUpper);
  var wGradient = rand(wLower, wUpper);

  // console.log("hLower: " + hLower);
  // console.log("hUpper: " + hUpper);
  // console.log("wLower: " + wLower);
  // console.log("wUpper: " + wUpper);
  // console.log("hGradient " + hGradient);
  // console.log("wGradient " + wGradient);

  var res = ctx.createLinearGradient(iHOffset, 0, wGradient, hGradient);
  res.addColorStop(0,colorToS(cForeground));

  var cFade = randAlphaC(cForeground, 0.2, 0.6);
  res.addColorStop(1,colorToS(cFade));
  return res;
}

function typeCharacter(ctx, sChar, sNextChar, pos,
                       iHeight, iLineHeight, iElementWidth, cForeground,
                       cBackground) {
  var iWidth = ctx.measureText(sChar).width | 0;
  var iHOffset = pos[0];

  var iVOffset = pos[1];
  if ((iWidth + iHOffset) > iElementWidth) {
    iHOffset = 0;
    iVOffset = iVOffset + iLineHeight;
  }
  
  var iHalfHeight = (iLineHeight / 2) | 0;

  // render transposition typographical errors.
  if (sChar != " " && sNextChar && chance(2)) {
    var cTypo = randAlphaC(cForeground, 0.5, 0.7);
    ctx.fillStyle = generateInkStrike(ctx, iHOffset, iWidth,
                      iHeight, cTypo, cBackground);                     // approximate type bar strike.
    ctx.fillText(sNextChar, iHOffset, iWidth+iVOffset+rand(0,2));
  }

  // render smudges / deepened bleed for characters with enclosing strokes.
  if (smudge.indexOf(sChar.toLowerCase()) != -1 && chance(10)) {
    // console.log("s: " + s);
    // console.log("h: " + h);
    // console.log("width: " + w);
    // console.log("height: " + h);

    var grd = ctx.createRadialGradient(iHOffset+rand(iWidth/3,iWidth/2), iHalfHeight, 1,
                       iHOffset+rand(iWidth/3,iWidth/2), iHalfHeight, iWidth/2+1);

    grd.addColorStop(0, colorToS(randAlphaC(cForeground, 0.0, 0.6)));
    grd.addColorStop(1, colorToS(cBackground));
    ctx.fillStyle = grd;
    ctx.fillRect(iHOffset, 0, iWidth, iHeight);
  }

  // render the character tho the canvas.
  ctx.fillStyle=generateInkStrike(ctx, iHOffset, iWidth,
                                  iHeight, cForeground, cBackground);   // approximate type bar strike.
  ctx.fillText(sChar, iHOffset, iWidth+iVOffset+rand(0,2));             // render foundation character.
  ctx.fillText(sChar, iHOffset+rand(0, 1), iWidth+iVOffset+rand(0,2));  // bleed character onto the page.

  return [iHOffset + iWidth, iVOffset];
}

function typeWord(ctx, word, position) {
  var fWidth = ctx.measureText(word).width;


  console.log(word+"-"+fWidth);

  return position;
}

function buildLines(ctx, sContent, iMaxWidth) {
  var aLines = new Array();

  // Estimte number of characters that can fit on a line.
  var iCharWidth = Math.ceil(ctx.measureText(sContent[0]).width) | 0;
  var iMaxLineLength = Math.floor(iMaxWidth / iCharWidth) | 0;

  var iPrevLineIndex = 0;
  var iLineEnd = sContent.length;
  var sRemainingContent = sContent;

  // Break the content into lines, making sure we don't split words.
  while (sRemainingContent.length > iMaxLineLength) {
    var iCurrentLineLength = Math.min(sRemainingContent.length, iMaxLineLength);
    iLineEnd = sRemainingContent.substring(iPrevLineIndex, iCurrentLineLength).lastIndexOf(" ");

    aLines.push(sRemainingContent.substring(iPrevLineIndex, iLineEnd));

    iPrevLineIndex = iPrevLineIndex + iLineEnd;
    sRemainingContent = sRemainingContent.substring(iPrevLineIndex).trim();
  }

  aLines.push(sRemainingContent.substring(iPrevLineIndex, iLineEnd));

  return aLines;
}

function typeParagraph(eExisting) {
  // Create canvas element that we will use to re-render the content off the existing element.
  var eCanvas = document.createElement("canvas");
  var existingStyle = eExisting.currentStyle || window.getComputedStyle(eExisting);

  // Model the width and the height of the canvas off the existing element.
  var iElementWidth = eExisting.offsetWidth;
  eCanvas.setAttribute("width", eExisting.offsetWidth);
  eCanvas.setAttribute("height", eExisting.offsetHeight);

  // Copy the basic display settings across.
  eCanvas.style.border = existingStyle.border;
  eCanvas.style.display = existingStyle.display;
  eCanvas.style.margin = existingStyle.margin;
  eCanvas.style.padding = existingStyle.padding;
  //eCanvas.innerHTML = 'Your browser does not support the HTML5 canvas tag.';

  // Model the size of the type off the existing element.
  var iSize = parseInt(existingStyle.getPropertyValue('font-size'));

  // Configure our canvas rendering context.
  var ctx = eCanvas.getContext("2d");
  ctx.font = iSize + "px \"Courier New\",monospace";
 
  // Estimate lines.
  var iLines = eExisting.offsetHeight / iSize | 0;
  var iMarginTop = parseInt(existingStyle.getPropertyValue('border-top-width'))
  var iMarginBottom = parseInt(existingStyle.getPropertyValue('border-bottom-width'))
  var iLineHeight = (eExisting.offsetHeight + (iMarginTop + iMarginBottom) )/ iLines;
  var cForeground = parseColor(existingStyle.color);
  var cBackground = parseColor(existingStyle.backgroundColor);

  var aLines = buildLines(ctx, eExisting.innerHTML, eExisting.offsetWidth);

  // Start pecking away at our virtual typewritter.
  var iVOffset = iLineHeight - iSize;
  var iHOffset = 0
  var pos = [iHOffset, iVOffset];

  for(var i = 0, len = eExisting.innerHTML.length; i < len; i++) {
    pos = typeCharacter(ctx, eExisting.innerHTML[i], eExisting.innerHTML[i+1],
                        pos, iSize, iLineHeight, iElementWidth, cForeground, cBackground);
  }

  eExisting.parentNode.insertBefore(eCanvas, eExisting);
  eExisting.style.display = 'none'; // Hide the original content. The canvas has replaced it.
}

// For each tag marked with the analogue class -- replace the content with a canvas typeset with analogue.
var aTypingList = document.querySelectorAll(".analogue");
for (var i = 0, len = aTypingList.length; i < len; i++) {
  typeParagraph(aTypingList[i])
}
</script>

</body>
</html>